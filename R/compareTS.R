#' @title Community Time Series Comparison with generateTS
#' @description Compare community time series generated with generateTS.
#'
#' @details If R package infotheo is installed, the entropy of time series
#' is computed.
#'
#' @param input.folder the folder where results (settings and time series) of function generateTS are stored.
#' @param expIds the experiment identifiers of time series to be considered
#' @param modif.folder the folder with time series sub-sets as generated by sliceTS.R or with noisy time series as generated by addNoise.R (settings are read in from input.folder)
#' @param modif modification (shared name of time series in modif.folder, sliced for time series sub-sets and pois for time series with Poisson noise added)
#' @param sliceDef consider the time series sub-set defined by the given start and end time point for property computation, an end time point of NA means that the entire time series is considered; timeDecaySliceDef refers to the outcome of sliceDef
#' @param epsilon allowed deviation from the expected slope for noise type identification
#' @param norm normalize time series by dividing each entry in a sample by the sum of its sample; if norm is true, entropy computation is omitted
#' @param hurstBins binning thresholds for Hurst exponent (three thresholds required for four bins)
#' @param maxautocorBins binning thresholds for maximal autocorrelation (three thresholds required for four bins)
#' @param timeDecaySliceDef the time series subset considered to compute the time decay, a vector with the start and the end time point (if the end time point is NA, the entire time series is used)
#' @param varEvolSliceDef the time series subset considered to compute the evolution of variance, a vector with the start and the end time point (if the end time point is NA, the entire time series is used)
#' @param returnDistribs return distributions at the final time point (no time series properties are computed, cannot be used together with returnTS)
#' @param returnTS return the time series (no time series properties are computed, cannot be used together with returnDistribs)
#' @return a table with experiment parameters (algorithm, connectance, sigma, theta and so on) and time series properties (noise types, slope of Taylor's law etc.); if returnDistrib is true, a list with the abundances at the last time point, if returnTS is true, a list with the time series
#' @export

compareTS <- function(input.folder="",expIds=c(), modif.folder="", modif="", sliceDef=c(1,NA), epsilon=0.2, norm=FALSE, hurstBins=c(0.5,0.7,0.9), maxautocorBins=c(0.3,0.5,0.8), timeDecaySliceDef=c(1,50), varEvolSliceDef=c(), returnDistribs=FALSE, returnTS=FALSE){

  # infotheo needed for entropy computation
  infotheoThere=TRUE
  if (!require("infotheo")) {
    infotheoThere=FALSE
  }

  if(length(hurstBins) != 3){
    stop("Three Hurst bin thresholds required!")
  }

  if(length(maxautocorBins) != 3){
    stop("Three maximal autocorrelation bin thresholds required!")
  }

  if(returnDistribs==TRUE && returnTS==TRUE){
    stop("Cannot use returnDistribs and returnTS together.")
  }

  if(input.folder != ""){
    if(!file.exists(input.folder)){
      stop(paste("The input folder",input.folder,"does not exist!"))
    }
    input.settings.folder=paste(input.folder,"settings",sep="/")
    if(!file.exists(input.settings.folder)){
      stop("The input folder does not have a settings subfolder!")
    }
    if(modif.folder == ""){
      input.timeseries.folder=paste(input.folder,"timeseries",sep="/")
      if(!file.exists(input.timeseries.folder)){
        stop("The input folder does not have a time series subfolder!")
      }
    }else{
      if(!file.exists(modif.folder)){
        stop("The folder with sliced time series does not exist!")
      }
    }
  }else{
    stop("Please provide the input folder!")
  }

  # experiment properties
  taxa=c()
  samples=c()
  peps=c()
  initmode=c()
  connectances=c()
  algorithms=c()
  sigmas=c()
  thetas=c()
  migrations=c()
  deathrates=c()
  individuals=c()
  samplingfreqs=c()

  # time series properties
  taylorslopes=c()
  taylorR2=c()
  timedecayslopes=c()
  timedecayR2=c()
  varevolslopes=c()
  varevolR2=c()
  percentblack=c()
  percentbrown=c()
  percentpink=c()
  percentwhite=c()
  # from lowest to highest maximal autocorrelation
  binA4Name=paste("autocor",maxautocorBins[3],"Inf",sep="")
  binA3Name=paste("autocor",maxautocorBins[2],maxautocorBins[3],sep="")
  binA2Name=paste("autocor",maxautocorBins[1],maxautocorBins[2],sep="")
  binA1Name=paste("autocor","negInf",maxautocorBins[1],sep="")
  percentmaxautocorbin1=c()
  percentmaxautocorbin2=c()
  percentmaxautocorbin3=c()
  percentmaxautocorbin4=c()
  binH4Name=paste("hurst",hurstBins[3],"Inf",sep="")
  binH3Name=paste("hurst",hurstBins[2],hurstBins[3],sep="")
  binH2Name=paste("hurst",hurstBins[1],hurstBins[2],sep="")
  binH1Name=paste("hurst","negInf",hurstBins[1],sep="")
  lowHursts=c()
  middleHursts=c()
  highHursts=c()
  veryHighHursts=c()
  entropy=c()
  autoslopes=c()

  # distribution list
  distribList = list()

  # time series list
  tsList = list()

  # collect time series properties
  for(expId in expIds){

    print(paste("Processing identifier",expId))

    input.settings.name=paste(expId,"settings",sep="_")
    input.settings.expId.folder=paste(input.settings.folder,input.settings.name,sep="/")
    #print(input.settings.expId.folder)
    if(!file.exists(input.settings.expId.folder)){
      stop("The input settings folder does not have a subfolder for the input experiment identifier!")
    }

    if(modif.folder == ""){
      input.timeseries.name=paste(expId,"timeseries",sep="_")
      input.timeseries.expId.folder=paste(input.timeseries.folder,input.timeseries.name,sep="/")
      if(!file.exists(input.timeseries.expId.folder)){
        stop("The input time series folder does not have a subfolder for the input experiment identifier!")
      }
    }

    # read settings file
    input.settings.expId.file=paste(expId,"settings.txt",sep="_")
    settings.path=paste(input.settings.expId.folder,input.settings.expId.file,sep="/")
    if(!file.exists(settings.path)){
      stop(paste("The settings file",settings.path,"does not exist!"))
    }
    source(settings.path)

    algorithms=c(algorithms,Algorithm)
    samplingfreqs=c(samplingfreqs,Sampling_frequency)

    # read interaction matrix
    if(returnDistribs == FALSE && returnTS==FALSE){
      if(Algorithm == "ricker" || Algorithm == "soc" || Algorithm == "glv"){
        source.expId = expId
        interactionmatrix.folder=input.settings.expId.folder
        # interaction matrix for current experiment was read from another experiment
        if(!is.na(Input_experiment_identifier) && Input_experiment_identifier!=FALSE){
          source.expId=Input_experiment_identifier
          source.expId.folder=paste(source.expId,"settings",sep="_")
          interactionmatrix.folder=paste(input.settings.folder,source.expId.folder,sep="/")
        }
        A.name=paste(source.expId,"interactionmatrix.txt",sep="_")
        input.path.A=paste(interactionmatrix.folder,A.name,sep="/")
        print(paste("Reading interaction matrix from:",input.path.A,sep=" "))
        A=read.table(file=input.path.A,sep="\t",header=FALSE)
        A=as.matrix(A)
        # the requested and target PEP differ
        peps=c(peps,round(getPep(A),2))
        connectances=c(connectances,getConnectance(A))
      }else{
        peps=c(peps,NA)
        connectances=c(connectances,NA)
      }
    }

    initmode=c(initmode,init_abundance_mode)

    # read algorithm-specific parameters
    if(Algorithm == "ricker"){
      sigmas=c(sigmas,sigma)
    }else{
      sigmas=c(sigmas,NA)
    }
    if(Algorithm == "dm"){
      thetas=c(thetas,theta)
    }else{
      thetas=c(thetas,NA)
    }
    if(Algorithm == "hubbell"){
      migrations=c(migrations,immigration_rate_Hubbell)
      deathrates=c(deathrates, deathrate_Hubbell)
    }else{
      migrations=c(migrations,NA)
      deathrates=c(deathrates,NA)
    }
    if(Algorithm == "soc" || Algorithm == "hubbell"){
      individuals=c(individuals,I)
      #print(paste("individuals",I))
    }else{
      individuals=c(individuals,NA)
    }

    # read time series file
    if(modif.folder == ""){
      ts.name=paste(expId,"timeseries.txt",sep="_")
      input.path.ts=paste(input.timeseries.expId.folder,ts.name,sep="/")
    }else{
      ts.name=paste(expId,modif,"timeseries.txt",sep="_")
      input.path.ts=paste(modif.folder, ts.name, sep="/")
    }
    print(paste("Reading time series from:",input.path.ts,sep=" "))
    ts=read.table(file=input.path.ts,sep="\t",header=FALSE)
    ts=as.matrix(ts)
    if(norm==TRUE){
      ts=seqtime::normalize(ts)
    }
    if(sliceDef[1]>1 || !is.na(sliceDef[2])){
      subsetStart=sliceDef[1]
      subsetStop=sliceDef[2]
      if(subsetStop > ncol(ts)){
        warning(paste("Time series",expId,"has less samples (namely",ncol(ts),") than the given end point! The last time point is used instead!"))
        subsetStop=ncol(ts)
      }
      if(is.na(sliceDef[2])){
        subsetStop=ncol(ts)
      }
      ts=ts[,subsetStart:subsetStop]
    }
    N=nrow(ts)
    print(paste("Read time series with",N,"taxa and",ncol(ts),"samples."))
    onePerc=N/100
    taxa=c(taxa,N)
    samples=c(samples,ncol(ts))

    if(returnDistribs == FALSE && returnTS==FALSE){
      # entropy
      if(infotheoThere == TRUE && norm==FALSE){
        # discretization needed (also for David data, because of interpolation)
        if(Algorithm=="glv" || Algorithm == "ricker" || Algorithm == "davida" || Algorithm == "davidb"){
          disc=discretize(t(ts),disc="equalwidth")
          ent=entropy(disc)
        }else{
          ent=entropy(t(ts))
        }
        entropy=c(entropy,ent)
      }else{
        entropy=c(entropy,NA)
      }

      # auto-correlation vs species number slope
      autocorOut=autocorVsTaxonNum(ts,lag=1,plot=FALSE)
      autoslopes=c(autoslopes,autocorOut$slope)

      # bin Hurst exponent
      hursts=binByMemory(ts,thresholds=hurstBins,method="hurst")
      lowHursts=c(lowHursts,onePerc*(length(hursts[[binH1Name]])/100))
      middleHursts=c(middleHursts,onePerc*(length(hursts[[binH2Name]])/100))
      highHursts=c(highHursts,onePerc*(length(hursts[[binH3Name]])/100))
      veryHighHursts=c(veryHighHursts,onePerc*(length(hursts[[binH4Name]])/100))

      # bin maximal autocorrelations
      autocorBins=binByMemory(ts,thresholds=maxautocorBins,method="autocor")
      percentmaxautocorbin4=c(percentmaxautocorbin4, onePerc*(length(autocorBins[[binA4Name]])/100))
      percentmaxautocorbin3=c(percentmaxautocorbin3, onePerc*(length(autocorBins[[binA3Name]])/100))
      percentmaxautocorbin2=c(percentmaxautocorbin2, onePerc*(length(autocorBins[[binA2Name]])/100))
      percentmaxautocorbin1=c(percentmaxautocorbin1, onePerc*(length(autocorBins[[binA1Name]])/100))

      # calculate taylor's law slope
      taylorRes=taylor(ts,type="taylor",plot=FALSE, pseudo=0.0000001)
      noisetypesRes=identifyNoisetypes(ts,abund.threshold = 0, epsilon=epsilon)

      taylorslopes=c(taylorslopes,taylorRes$slope)
      taylorR2=c(taylorR2,taylorRes$adjR2)
      percentbrown=c(percentbrown,onePerc*(length(noisetypesRes$brown)/100))
      percentpink=c(percentpink,onePerc*(length(noisetypesRes$pink)/100))
      percentwhite=c(percentwhite,onePerc*(length(noisetypesRes$white)/100))
      percentblack=c(percentblack,onePerc*(length(noisetypesRes$black)/100))

      # evolution of variance
      if(length(varEvolSliceDef)==2){
        startTD=varEvolSliceDef[1]
        stopTD=varEvolSliceDef[2]
        if(is.na(stopTD)){
          stopTD=ncol(ts)
        }
        if(ncol(ts) < startTD){
          stop(paste("Time series",expId,"has less samples (namely",ncol(ts),") than the given start point for variance evolution!"))
        }
        if(ncol(ts) < stopTD){
          warning(paste("Time series",expId,"has less samples (namely",ncol(ts),") than the given end point for variance evolution! The last time point is used instead!"))
          stopTD=ncol(ts)
        }
        varEvolSlice=ts[,startTD:stopTD]
        varEvolRes=varEvol(varEvolSlice, plot=FALSE)
        varevolslopes=c(varevolslopes,varEvolRes$slope)
        varevolR2=c(varevolR2,varEvolRes$adjR2)
      }else{
        if(length(varEvolSliceDef)>0){
          warning("The variance evolution slice is not defined correctly!")
        }
        varevolslopes=c(varevolslopes,NA)
        varevolR2=c(varevolR2,NA)
      }

      # time decay
      if(length(timeDecaySliceDef)==2){
        startTD=timeDecaySliceDef[1]
        stopTD=timeDecaySliceDef[2]
        if(is.na(stopTD)){
          stopTD=ncol(ts)
        }
        if(ncol(ts) < startTD){
          stop(paste("Time series",expId,"has less samples (namely",ncol(ts),") than the given start point for the time decay!"))
        }
        if(ncol(ts) < stopTD){
          warning(paste("Time series",expId,"has less samples (namely",ncol(ts),") than the given end point for the time decay! The last time point is used instead!"))
          stopTD=ncol(ts)
        }
        timeDecaySlice=ts[,startTD:stopTD]
        timedecayRes=timeDecay(timeDecaySlice, plot=FALSE, logdissim=TRUE, logtime=TRUE)
        timedecayslopes=c(timedecayslopes,timedecayRes$slope)
        timedecayR2=c(timedecayR2,timedecayRes$adjR2)
      }else{
        warning("The time decay slice is not defined correctly!")
        timedecayslopes=c(timedecayslopes,NA)
        timedecayR2=c(timedecayR2,NA)
      }
    }else if(returnDistribs==TRUE){
      # last column
      name=paste("exp",expId,sep="")
      distribList[[name]]=ts[,ncol(ts)]
    }else if(returnTS==TRUE){
      name=paste("exp",expId,sep="")
      tsList[[name]]=ts
    }
  } # end loop over experiments

  # assemble table
  if(returnDistribs == FALSE && returnTS == FALSE){
    resulttable=list(expIds,samples,algorithms,samplingfreqs,initmode,peps,connectances,sigmas,thetas,migrations,individuals, deathrates,entropy,taylorslopes,taylorR2, percentblack,percentbrown,percentpink,percentwhite,percentmaxautocorbin1,percentmaxautocorbin2,percentmaxautocorbin3,percentmaxautocorbin4, lowHursts, middleHursts, highHursts,veryHighHursts, timedecayslopes, timedecayR2, varevolslopes, varevolR2, autoslopes)
    names(resulttable)=c("id","samplenum","algorithm","interval","initabundmode","pep","c","sigma","theta","m","individuals","deaths","entropy","taylorslope","taylorr2","black","brown","pink","white","maxautocorbin1","maxautocorbin2","maxautocorbin3","maxautocorbin4", "lowhurst","middlehurst","highhurst","veryhighhurst","timedecayslope","timedecayr2","varevolslope","varevolr2","autoslope")
  }else if(returnDistribs == TRUE){
    resulttable=distribList
  }else if(returnTS == TRUE){
    resulttable=tsList
  }
  return(resulttable)
}
