#' Compare community time series generated with generateTS
#'
#' If R package infotheo is installed, the entropy of time series
#' is computed.
#'
#' @param input.folder the folder where results of function generateTS are stored.
#' @param expIds the experiment identifiers of time series to be considered
#' @param sliced.folder the folder with time series sub-sets as generated by sliceTS.R
#' @param timeDecayInterval the interval considered to compute the time decay
#' @param returnDistribs return distributions at the final time point
#' @return a table with experiment parameters (algorithm, connectance, sigma, theta and so on) and time series properties (noise types, slope of Taylor's law etc.)
#' @export

compareTS<-function(input.folder="",expIds=c(), sliced.folder="", timeDecayInterval=20, returnDistribs=FALSE){

  # infotheo needed for entropy computation
  infotheoThere=TRUE
  if (!require("infotheo")) {
    infotheoThere=FALSE
  }

  if(input.folder != ""){
    if(!file.exists(input.folder)){
      stop(paste("The input folder",input.folder,"does not exist!"))
    }
    input.settings.folder=paste(input.folder,"settings",sep="/")
    if(!file.exists(input.settings.folder)){
      stop("The input folder does not have a settings subfolder!")
    }
    if(sliced.folder == ""){
      input.timeseries.folder=paste(input.folder,"timeseries",sep="/")
      if(!file.exists(input.timeseries.folder)){
        stop("The input folder does not have a time series subfolder!")
      }
    }else{
      if(!file.exists(sliced.folder)){
        stop("The folder with sliced time series does not exist!")
      }
    }
  }else{
    stop("Please provide the input folder!")
  }

  # experiment properties
  taxa=c()
  samples=c()
  peps=c()
  initmode=c()
  connectances=c()
  algorithms=c()
  sigmas=c()
  thetas=c()
  migrations=c()
  deathrates=c()
  individuals=c()
  samplingfreqs=c()

  # time series properties
  taylorslopes=c()
  taylorR2=c()
  timedecayslopes=c()
  timedecayR2=c()
  percentblack=c()
  percentbrown=c()
  percentpink=c()
  percentwhite=c()
  percentmaxautocor8to1=c()
  percentmaxautocor5to8=c()
  percentmaxautocor3to5=c()
  percentmaxautocor0to3=c()
  lowHursts=c()
  middleHursts=c()
  highHursts=c()
  veryHighHursts=c()
  entropy=c()

  # distribution list
  distribList = list()

  # collect time series properties
  for(expId in expIds){

    print(paste("Processing identifier",expId))

    input.settings.name=paste(expId,"settings",sep="_")
    input.settings.expId.folder=paste(input.settings.folder,input.settings.name,sep="/")
    if(!file.exists(input.settings.expId.folder)){
      stop("The input settings folder does not have a subfolder for the input experiment identifier!")
    }

    if(sliced.folder == ""){
      input.timeseries.name=paste(expId,"timeseries",sep="_")
      input.timeseries.expId.folder=paste(input.timeseries.folder,input.timeseries.name,sep="/")
      if(!file.exists(input.timeseries.expId.folder)){
        stop("The input time series folder does not have a subfolder for the input experiment identifier!")
      }
    }

    # read settings file
    input.settings.expId.file=paste(expId,"settings.txt",sep="_")
    settings.path=paste(input.settings.expId.folder,input.settings.expId.file,sep="/")
    if(!file.exists(settings.path)){
      stop(paste("The settings file",settings.path,"does not exist!"))
    }
    source(settings.path)

    algorithms=c(algorithms,Algorithm)
    samplingfreqs=c(samplingfreqs,Sampling_frequency)

    # read interaction matrix
    if(returnDistribs == FALSE){
      if(Algorithm == "ricker" || Algorithm == "soc" || Algorithm == "glv"){
        source.expId = expId
        interactionmatrix.folder=input.settings.expId.folder
        # interaction matrix for current experiment was read from another experiment
        if(!is.na(Input_experiment_identifier)){
          source.expId=Input_experiment_identifier
          source.expId.folder=paste(source.expId,"settings",sep="_")
          interactionmatrix.folder=paste(input.settings.folder,source.expId.folder,sep="/")
        }
        A.name=paste(source.expId,"interactionmatrix.txt",sep="_")
        input.path.A=paste(interactionmatrix.folder,A.name,sep="/")
        print(paste("Reading interaction matrix from:",input.path.A,sep=" "))
        A=read.table(file=input.path.A,sep="\t",header=FALSE)
        A=as.matrix(A)
        # the requested and target PEP differ
        peps=c(peps,round(getPep(A),2))
        connectances=c(connectances,getConnectance(A))
      }else{
        peps=c(peps,NA)
        connectances=c(connectances,NA)
      }
    }

    initmode=c(initmode,init_abundance_mode)

    # read algorithm-specific parameters
    if(Algorithm == "ricker"){
      sigmas=c(sigmas,sigma)
    }else{
      sigmas=c(sigmas,NA)
    }
    if(Algorithm == "dm"){
      thetas=c(thetas,theta)
    }else{
      thetas=c(thetas,NA)
    }
    if(Algorithm == "hubbell"){
      migrations=c(migrations,immigration_rate_Hubbell)
      deathrates=c(deathrates, deathrate_Hubbell)
    }else{
      migrations=c(migrations,NA)
      deathrates=c(deathrates,NA)
    }
    if(Algorithm == "soc" || Algorithm == "hubbell"){
      individuals=c(individuals,I)
      #print(paste("individuals",I))
    }else{
      individuals=c(individuals,NA)
    }

    # read time series file
    if(sliced.folder == ""){
      ts.name=paste(expId,"timeseries.txt",sep="_")
      input.path.ts=paste(input.timeseries.expId.folder,ts.name,sep="/")
    }else{
      ts.name=paste(expId,"sliced_timeseries.txt",sep="_")
      input.path.ts=paste(sliced.folder, ts.name, sep="/")
    }
    print(paste("Reading time series from:",input.path.ts,sep=" "))
    ts=read.table(file=input.path.ts,sep="\t",header=FALSE)
    ts=as.matrix(ts)
    N=nrow(ts)
    print(paste("Read time series with",N,"taxa and",ncol(ts),"samples."))
    onePerc=N/100
    taxa=c(taxa,N)
    samples=c(samples,ncol(ts))

    if(returnDistribs == FALSE){
      # entropy
      if(infotheoThere == TRUE){
        # discretization needed (also for David data, because of interpolation)
        if(Algorithm=="glv" || Algorithm == "ricker" || Algorithm == "davida" || Algorithm == "davidb"){
          disc=discretize(t(ts),disc="equalwidth")
          ent=entropy(disc)
        }else{
          ent=entropy(t(ts))
        }
        entropy=c(entropy,ent)
      }else{
        entropy=c(entropy,NA)
      }

      # bin Hurst exponent
      hursts=binByMemory(ts,thresholds=c(0.5,0.7,0.9),method="hurst")
      lowHursts=c(lowHursts,onePerc*(length(hursts$hurst00.5)/100))
      middleHursts=c(middleHursts,onePerc*(length(hursts$hurst0.50.7)/100))
      highHursts=c(highHursts,onePerc*(length(hursts$hurst0.70.9)/100))
      veryHighHursts=c(veryHighHursts,onePerc*(length(hursts$hurst0.9Inf)/100))

      # bin maximal autocorrelations
      autocorBins=binByMemory(ts,thresholds=c(0.3,0.5,0.8),method="autocor")
      percentmaxautocor8to1=c(percentmaxautocor8to1, onePerc*(length(autocorBins$autocor0.8Inf)/100))
      percentmaxautocor5to8=c(percentmaxautocor5to8, onePerc*(length(autocorBins$autocor0.50.8)/100))
      percentmaxautocor3to5=c(percentmaxautocor3to5, onePerc*(length(autocorBins$autocor0.30.5)/100))
      percentmaxautocor0to3=c(percentmaxautocor0to3, onePerc*(length(autocorBins$autocor00.3)/100))

      # calculate taylor's law slope
      taylorRes=taylor(ts,type="taylor",plot=FALSE, pseudo=0.0000001)
      #timedecayRes=timeDecay(ts,plot=FALSE)
      noisetypesRes=identifyNoisetypes(ts,abund.threshold = 0)

      taylorslopes=c(taylorslopes,taylorRes$slope)
      taylorR2=c(taylorR2,taylorRes$adjR2)
      percentbrown=c(percentbrown,onePerc*(length(noisetypesRes$brown)/100))
      percentpink=c(percentpink,onePerc*(length(noisetypesRes$pink)/100))
      percentwhite=c(percentwhite,onePerc*(length(noisetypesRes$white)/100))
      percentblack=c(percentblack,onePerc*(length(noisetypesRes$black)/100))

      # if we do not sub-sample, it is very slow for 3000 samples
      if(!is.na(timeDecayInterval)){
        if(ncol(ts) < timeDecayInterval){
          stop(paste("Time series",expId,"has less samples (namely",ncol(ts),") than the given time decay interval!"))
        }
        ts=tsubsample(ts, interval=timeDecayInterval)
      }
      timedecayRes=timeDecay(ts, plot=FALSE)
      timedecayslopes=c(timedecayslopes,timedecayRes$slope)
      timedecayR2=c(timedecayR2,timedecayRes$adjR2)
    }else{
      # last column
      name=paste("exp",expId,sep="")
      distribList[[name]]=ts[,ncol(ts)]
    }
  } # end loop over experiments

  # assemble table
  if(returnDistribs == FALSE){
    resulttable=list(expIds,samples,algorithms,samplingfreqs,initmode,peps,connectances,sigmas,thetas,migrations,individuals, deathrates,entropy,taylorslopes,taylorR2, percentblack,percentbrown,percentpink,percentwhite,percentmaxautocor0to3,percentmaxautocor3to5,percentmaxautocor5to8,percentmaxautocor8to1, lowHursts, middleHursts, highHursts,veryHighHursts, timedecayslopes, timedecayR2)
    names(resulttable)=c("id","samplenum","algorithm","interval","initabundmode","pep","c","sigma","theta","m","individuals","deaths","entropy","taylorslope","taylorr2","black","brown","pink","white","maxautocorbelow03","maxautocor03to05","maxautocor05to08","maxautocor08to1", "lowhurst","middlehurst","highhurst","veryhighhurst","timedecayslope","timedecayr2")
  }else{
    resulttable=distribList
  }
  return(resulttable)
}
