#' Simulate a matrix composed of rows with different noise types.
#'
#' White noise is generated with rnorm and brown noise with cumsum(rnorm).
#' Pink noise is generated by default with the voss1d function from the Voss package.
#' Alternatively, pink noise can be generated by filtering the power spectrum of
#' white noise, which is however less reliable.
#'
#' @param samples the number of samples to be drawn
#' @param noisetypes a list specifying the number of rows to be generated for each noise type
#' @param pink.type the algorithm to generate pink noise, options: white and voss
#' @return a matrix where each row represents a distribution following a specified noise type
#' @examples
#' # plot the power spectrum of pink noise
#' powerspec(simNoiseMat(samples=100,noisetypes=list(white=0,brown=0,pink=1))[1,],plot.log=TRUE)
#' # plot a matrix with mixed noise types
#' mat=simNoiseMat(samples=300,noisetypes=list(white=0,brown=20,pink=30))
#' tsplot(mat,type="l", header="simulated noise")
#' # Taylor law of brown noise
#' taylor(simNoiseMat(samples=300,noisetypes=list(white=0,brown=50,pink=0)),type="taylor")
#' @export

simNoiseMat<-function(samples=100, noisetypes=list(white=2,brown=3,pink=5), pink.type="voss"){
  noiseMat=matrix(nrow=noisetypes$white+noisetypes$brown+noisetypes$pink,ncol=samples)
  counter=1
  # generate requested number of instances of white noise
  if(noisetypes$white > 0){
    for(i in 1:noisetypes$white){
      # white noise:  slope in log-log spectral plot around 0
      noiseMat[counter,]=rnorm(samples,mean=0,sd=1);
      counter = counter+1
    }
  }
  # generate requested number of instances of brown noise
  if(noisetypes$brown > 0){
    for(i in 1:noisetypes$brown){
      # brown noise:  slope in log-log spectral plot around -2
      noiseMat[counter,]=cumsum(rnorm(samples,mean=0,sd=1));
      counter = counter+1
    }
  }
  # generate requested number of instances of pink noise
  if(noisetypes$pink > 0){
    for(i in 1:noisetypes$pink){
      # pink noise:  slope in log-log spectral plot around -1
      # generate pink from white noise
      if(pink.type == "white"){
        noiseMat[counter,]=white2pink(rnorm(samples))
      }
      # generate pink noise with Voss' algorithm
      # with H close to zero, this generates values around -1 with very low p-values
      # Problem: there is no way to specify the number of samples
      # but vectors can be combined until the desired sample number is reached
      else if(pink.type == "voss"){
        fractalbrown=c()
        while(length(fractalbrown) < samples){
          fractalbrown=c(fractalbrown, Voss::voss1d(H=0.001)$y)
        }
        noiseMat[counter,]=fractalbrown[1:samples]
      }else{
        stop("Please specify the algorithm for pink noise, either voss or white")
      }
      counter = counter + 1
    }
  }
  return(noiseMat)
}

# Generate pink noise by manipulating the power spectrum of white noise
# Function translated from:
# http://www.mathworks.com/matlabcentral/fileexchange/42919-pink--red--blue-and-violet-noise-generation-with-matlab-implementation/content/pinknoise.m
# Alternatively, look at: https://www.mathworks.com/matlabcentral/newsreader/view_thread/71461
# Rarely works.
# Example: powerspec(white2pink(rnorm(100),stand=TRUE),plot.log=TRUE)
white2pink<-function(white=rnorm(100), stand=FALSE){
  N=length(white)
  # make sure vector length is even
  if(mod(N,2)>0){
    M = N+1
  }else{
    M = N
  }
  white.fft=fft(white)
  NumUniquePts = M/2 + 1
  n = 1:NumUniquePts
  n = sqrt(n)
  # give less power to high frequencies
  white.fft[1:NumUniquePts]=white.fft[1:NumUniquePts]/n
  z <- complex(real = 0, imaginary = 1)
  # prepare a right half of the spectrum - a copy of the left one,
  # except the DC component and Nyquist frequency - they are unique
  for(i in M/2:2){
    # right half from M/2+1 to M   left half from M/2 to 2
    white.fft[NumUniquePts+i]=Re(white.fft[i])-z*Im(white.fft[i])
  }
   # real part of inverse fast fourier transform
  pink=Re(fft(white.fft,inverse=TRUE))[1:N]
  # mean of zero, standard deviation of 1
  if(stand == TRUE){
    pink = pink-mean(pink)
    pink = pink/sd(pink)
  }
  return(pink)
}

# Weierstrass gives fractal graphs
# for certain settings, pink noise is generated, but it is not reliable
# http://www.ams.org/journals/proc/1998-126-03/S0002-9939-98-04387-1/S0002-9939-98-04387-1.pdf
# Example: pink=weier(rnorm(100),k=1,a=2,b=4)
# plot(weier(c(1:100),k=0.1),type="l")
# powerspec(weier(c(1:100),k=0.3,a=2,b=4)) gives positive slope of 2.5
weier<-function(x,k=1,a=2,b=4,iter=100){
  value=0
  for(i in 1:iter){
    value = value+a^k*cos(2*pi*b^k*x)
  }
  return(value)
}
