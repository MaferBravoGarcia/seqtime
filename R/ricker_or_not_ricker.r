######################################################
# DETECT WHETHER OR NOT THE TIME SERIES UNDERLYING DYNAMICS CAN BE UNDERSTOOD IN TERMS OF A RICKER MODEL
######################################################

# the time series to analyse should be in wd/timeseries/xx_timeseries and 
# should be called xx_complete.txt where xx is a number

# each column of the timeseries is one species. 

rm(list = ls())

library(ggplot2)
library(geigen)
library(MASS)


source("apply_limits.R")

#choose time series to analyze
timeseries.list=4 #
#choose sampling method (ie, choose max number of species kept, time skip, length kept)
Nmax= 20
tskip.list=c(1)       # j-loop  (if we choose tskip.list=c(1), we don't look for sub-sampling)
tend.max.list=c(500) # m-loop  (if only one value, we don't look at the effect of shortening the ts)
subsambpling=FALSE   #set to TRUE to look only at time points [1501:1600]
wd<-getwd()

#loop over the different time series to analyze
for(ll in timeseries.list){
  print(ll)
  #load the desired time series 
  namefile=paste(ll,"_timeseries",sep="") #name of the folder where this matrix is stored 
  file.path= paste(wd,"/timeseries/",namefile,sep="") #full name of the path to this folder
  R<-t(read.table(paste(file.path,"/ts_",ll,"_complete.txt",sep="")))
  sd=dim(R)
  N=sd[2]
  tmax=sd[1]
  print(paste("N is ",N," and tmax is ",tmax,sep=""))
  if(subsambpling==TRUE){
    if(tmax<1900) next
    R<-R[1501:1900,]
    sd=dim(R)
    N=sd[2]
    tmax=sd[1]
    }
  print(dim(R))
  #deal with too short time series
  if(N<Nmax){
    print(paste(ll," N is too small"))
    Nmax= N
  }
  if(tskip.list[length(tskip.list)]*tend.max.list[length(tend.max.list)]>tmax){
    tskip.list=c(1)         # j
    tend.max.list=c(round(tmax/3),round(tmax*2/3),tmax) # m
    print(paste(ll," tmax is too small"))
  }
  #if(length(which(colMeans(R)!=0,arr.ind=T))<=Nmax) next
  #  if(tmax<=tend.max.list[length(tend.max.list)]) next     #deal with too short time series
  #
  
  allindices<-seq(1,N)
  #initiate list of data frame that will contain 
  correlation.coefficients<-list()  # correlation coefficients between data and predicted data
  auto.correlation.coefficients<-list()  # auto-correlation coefficients (time series)
  mylistname<-list() #to label the different analysis
  corAB=0 #to keep correlation between original and inferred interaction matrix for each cases
      
  ######################################################
  #loop over the different sampling methods
  ######################################################
  
  indexlist = 1 #keep track of number of cases analysed
  
  for (j in 1:length(tskip.list)) {
    for (m in 1:length(tend.max.list)) {
      timepts <- seq(1,tmax,by = tskip.list[j]) # sampling of the time series
      Rtemp <- R[timepts,1:N]
      sd = dim(Rtemp)
      
      if (tend.max.list[m] > length(timepts)) next
      
      Rtemp <- Rtemp[1:tend.max.list[m],]
      namefile.specific = paste(ll,"_ts_N",Nmax,"_skip",tskip.list[j],'_tmax',dim(Rtemp)[1],sep ="")
      mylistname[[indexlist]] <- paste(ll,"_tmax",dim(Rtemp)[1],"_by_",tskip.list[j],sep = "")
      file.path.specific = paste(file.path,"/",namefile.specific,sep ="")
      dir.create(file.path(file.path.specific), showWarnings = FALSE)
      
      CC<-apply_limits(Rtemp,file.path.specific,Nmax = Nmax,tmax = tmax,percOKlist = c(.9,.7,.5,.4,.3,.2,.15,.1,.05,0),allindices =allindices)
        #import data generated by limits
        corr_table = CC[[2]]
        Best = CC[[1]]
        list.species.ordered=CC[[3]]
        
        #Z=sum(Rtemp[,]) not used but could be useful
        
        indexlist <- indexlist + 1
      
        }#end of m loop
      }#end of j loop
      
} #end of "l" loop








