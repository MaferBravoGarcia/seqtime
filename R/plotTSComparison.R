# Plot the time series comparison data generated by function compareTS.R
#
# The data object generated by function compareTS.R contains both time series properties and model parameters.
# Please use names(data) to list available slots.
# Important time series properties are: pink, brown, taylorslope, taylorr2, maxautocorbelow03, maxautocor08to1
# Important fitting properties are (function compareFit.R): slope, maxcorr, Acorr
# Important parameters are: interval, pep, sigma, theta
#
# data: output of compareTS.R, optionally merged with output of compareFit.R
# distribs: only needed for type rankabund, output of compareTS with returnDistribs set to TRUE
# colorBy: a model parameter by which to color, not supported by pca or by rankabund with any other generator than all
# type: the plot to do (boxplot, summary, rankabund or pca), boxplot will plot a boxplot with the property values per generator and color dots according to colorBy (requires ggplot2), summary will summarize noise types for each experiment, rankabund will do rank-abundance plots and pca will do a PCA plot across the 4 maximum autocorrelation bins
# property: a time series property (boxplot)
# jitter.width: jitter control (boxplot)
# dot.size: dot size control (boxplot)
# pcs: principal components (pca)
# useGgplot: use ggplot2 to create the summary plot (summary), requires ggplot2 and reshape2
# skipIntervals: only plot time series with interval 1 in the summary plot (summary)
# skipHighDeathrate: avoid hubbell time series with high death rate (>=1000) in the summary plot (summary)
# addInitAbund: add broken-stick-distributed initial abundances (rankabund)
# scale: scale abundances (subtract mean and divide by standard deviation, rankabund)
# logscale: take the logarithm of the abundances (rankabund)
# generator: generator for which rank-abundance curves should be plotted, defaults to all, options: glv, ricker, soc, dm, hubbell, davida, davidb, all
# pch: which point character to use for the plot (rankabund)
#
# Examples:
# plotTSComparison(table,property="black")

plotTSComparison<-function(data, distribs, colorBy="interval", type="boxplot", property="pink", jitter.width=0.1, dot.size=3, pcs=c(1,2), useGgplot=FALSE, skipIntervals=FALSE, skipHighDeathrate=FALSE, addInitAbund=TRUE, scale=FALSE, logscale=FALSE, generator="all", pch=""){
  if(!is.data.frame(data)){
    data=as.data.frame(data)
  }
  if(type=="rankabund" && !is.data.frame(distribs)){
    distribs=as.data.frame(distribs)
  }
  descript=property
  colorByDescript=colorBy
  if(property=="pink"){
    descript="percentage of pink OTUs"
  }else if(property=="brown"){
    descript="percentage of brown OTUs"
  }else if(property=="black"){
    descript="percentage of black OTUs"
  }else if(property == "maxautocor08to1"){
    descript="percentage of OTUs in maximum auto-correlation bin [0.8,1]"
  }else if(property == "maxautocor05to08"){
    descript="percentage of OTUs in maximum auto-correlation bin [0.5,0.8)"
  }else if(property == "maxautocor03to05"){
    descript="percentage of OTUs in maximum auto-correlation bin [0.3,0.5)"
  }else if(property == "maxautocorbelow03"){
    descript="percentage of OTUs in maximum auto-correlation bin [0,0.3]"
  }else if(property == "Acorr"){
    descript="mean correlation between estimated and predicted interaction matrix"
  }else if(property=="neutralfull" || property=="neutralslice"){
    descript="p-property"
  }else if(property=="maxcorr"){
    descript="maximum cross-correlation between predicted and observed time series"
  }else if(property=="taylorslope"){
    descript="slope of Taylor law"
  }else if(property=="taylorr2"){
    descript="R2 of Taylor law"
  }else if(property=="veryhighhurst"){
    descript="percentage of OTUs in Hurst property bin [0.9,1]"
  }else if(property=="deltaAest"){
    descript="range of inferred interaction strengths"
  }

  if(colorBy=="pep"){
    colorByDescript="PEP"
  }else if(colorBy=="initabundmode"){
    colorByDescript="initial abundance distribution type"
  }

  # check whether ggplot2 is there
  if(type=="boxplot" || (type=="summary") && useGgplot==TRUE){
    # check whether ggplot2 is there
    if (!require("ggplot2")) {
      stop("ggplot2 is not installed. Please install it.")
    }
  }

  if(type=="boxplot"){
    title=paste("Generator versus ",descript, " colored by ",colorByDescript,sep="")
    ymin=min(data[property],na.rm=TRUE)
    ymax=max(data[property],na.rm=TRUE)
    p <- ggplot(data, aes(factor(algorithm),data[property]))
    # remove legend title: theme(legend.title=element_blank())
    p + geom_boxplot() + geom_jitter(aes(colour=factor(unlist(data[colorBy]))), width=jitter.width, size=dot.size) + coord_cartesian(ylim=c(ymin,ymax)) + ggtitle(title) + xlab("Generator") + ylab(firstup(descript)) + theme(legend.title=element_blank())
  }else if(type=="summary"){
    if(skipIntervals==TRUE || skipHighDeathrate==TRUE){
      keepIndices=c()
      if(skipIntervals==TRUE){
        keepIndices=which(data$interval==1)
      }else{
        keepIndices=c(1:length(data$algorithm))
      }
      if(skipHighDeathrate==TRUE){
          deaths=data$deaths
          deaths[is.na(deaths)]=0
          temp=which(deaths<1000)
          keepIndices=intersect(keepIndices,temp)
      }
      filteredData=list(data$deaths[keepIndices],data$interval[keepIndices],data$algorithm[keepIndices], data$pink[keepIndices],data$brown[keepIndices],data$black[keepIndices])
      names(filteredData)=c("deaths","interval","algorithm","pink","brown","black")
      data=as.data.frame(filteredData)
    }
    # bar plot with OTU percentages in each noise category
    composition=matrix(NA,nrow=4, ncol=length(data$algorithm))
    labelcolors=c()
    for(i in 1:length(data$algorithm)){
      composition[1,i]=as.numeric(data$pink[i])
      composition[2,i]=as.numeric(data$brown[i])
      composition[3,i]=as.numeric(data$black[i])
      composition[4,i]=1-sum(composition[1:3,i])
      labelcolor="black"
      if(data$interval[i]==5){
        labelcolor="green"
      }else if(data$interval[i]==10){
        labelcolor="blue"
      }
      if(!is.na(data$deaths[i]) && data$deaths[i]>100){
        labelcolor="red"
      }
      labelcolors=c(labelcolors,labelcolor)
    }
    # re-arrange according to algorithm
    ricker=which(data$algorithm=="ricker")
    glv=which(data$algorithm=="glv")
    hubbell=which(data$algorithm=="hubbell")
    dm=which(data$algorithm=="dm")
    davida=which(data$algorithm=="davida")
    davidb=which(data$algorithm=="davidb")
    soc=which(data$algorithm=="soc")
    indices=c(ricker,glv,hubbell,dm,davida,davidb,soc)
    composition=composition[,indices]
    labelcolors=labelcolors[indices]
    names=c(rep("ricker",length(ricker)), rep("glv",length(glv)), rep("hubbell",length(hubbell)), rep("dm",length(dm)), rep("davida",length(davida)), rep("davidb",length(davidb)), rep("soc",length(soc)))
    colnames(composition)=names
    rownames(composition)=c("pink","brown","black","gray")
    if(useGgplot==TRUE){
      # check whether reshape2 is there
      if (!require("reshape2")) {
        stop("reshape2 is not installed. Please install it.")
      }
      mat=rbind(c(1:length(names)),composition)
      rownames(mat)=c("id",rownames(composition))
      df=as.data.frame(t(mat))
      df.m=reshape2::melt(df,id.var="id")
      ggplot(df.m, aes(x = id, y = value, fill = variable)) +
        geom_bar(stat = "identity") + ylab("Noise type percentages") + xlab("Experiment id") + scale_fill_manual(values=c("pink", "brown", "black", "gray"))
    }else{
      colnames(composition)=NULL
      par(las=2, srt=90, mar = c(5, 5, 4, 2))
      midpoints=barplot(composition,col=c("pink","brown","black","gray"), ylab="Noise type percentages",main="Noise type composition")
      mtext(names,col=labelcolors,side=1, cex=0.8, line=0.5, at=midpoints)
      # set default par
      par(las = 1, srt=0, cex=1, mar = c(4, 5, 4, 2))
    }
  }else if(type=="pca"){
    # with our without slope does not make much difference (joint$slope)
    mat=cbind(data$maxautocorbelow03, data$maxautocor03to05, data$maxautocor05to08, data$maxautocor08to1)
    mat=scale(mat)
    # correlations are computed column-wise by default
    out=my.pca(mat,useCor=TRUE, components=pcs)
    res=getColorVector(data)
    colvec=res$colors
    pchvec=res$symbols
    # with intervals indicated by shape
    plot(out$projection[1,],out$projection[2,], xlim=c(-3,3),col=colvec, bg=colvec, pch=pchvec, cex=1.5, xlab="PC1", ylab="PC2", main="PCA")
    algcolors=c("blue","gray","pink","brown","orange","green","red")
    legend(x="topright",legend=unique(data$algorithm), pch = rep(16,length(unique(data$algorithm))), col=algcolors, bg="white", text.col="black")
  }else if(type=="rankabund"){
    colvec=getColorVector(data)$colors
    algcolors=c("blue","gray","pink","brown","orange","green","red")
    # colorBy not supported for all
    if(generator=="all"){
      colorBy=""
    }
    if(addInitAbund==TRUE){
      distribs$y=generateAbundances(N=100,mode=5, count=1000, k=0.5, probabs=FALSE)
      # for initial abundances
      colvec=c(colvec,"black")
      algcolors=c(algcolors,"black")
    }
    xlab="Rank"
    if(logscale==TRUE){
      if(generator == "all" || scale==TRUE){
        ylab="Log(scaled abundance)"
      }else{
        ylab="Log(abundance)"
      }
    }else{
      if(generator=="all" || scale==TRUE){
        ylab="Scaled abundance"
      }else{
        ylab="Abundance"
      }
    }
    main="Rank-abundance curve of last time point"
    if(generator != "all"){
      main=paste(main,", generator: ",generator,sep="")
    }
    selectedAlg=generator
    if(generator == "all" || scale==TRUE){
      # carried out column-wise
      distribs=scale(distribs,center=FALSE, scale=TRUE)
    }
    if(generator == "all"){
      yRange = range(distribs, na.rm=T)
    }else{
      indices=which(data$algorithm==generator)
      yRange=range(distribs[, indices])

    }
    if(logscale==TRUE){
      yRange=c(0,3)
    }

    # not more than 5 values for any parameter
    param.colors = c("cyan","green","blue","orange","red")
    param.col.counter=1
    param.val.vs.col=list()
    param.plot.colors=c()

    plot(distribs[,1],ylim = yRange,xlab = xlab, ylab = ylab, main = main, type="n")
    for(i in 1:ncol(distribs)){
      doPlot=FALSE
      last=FALSE
      if(i == ncol(distribs)){
        last=TRUE
      }
      if(selectedAlg == "all"){
        doPlot=TRUE
      }
      if(selectedAlg == "hubbell" && colvec[i]=="gray"){
        doPlot=TRUE
      }
      if(selectedAlg == "dm" && colvec[i]=="pink"){
        doPlot=TRUE
      }
      if(selectedAlg == "ricker" && colvec[i]=="blue"){
        doPlot=TRUE
      }
      if(selectedAlg == "davida" && colvec[i]=="brown"){
        doPlot=TRUE
      }
      if(selectedAlg == "davidb" && colvec[i]=="orange"){
        doPlot=TRUE
      }
      if(selectedAlg == "soc" && colvec[i]=="green"){
        doPlot=TRUE
      }
      if(selectedAlg == "glv" && colvec[i]=="red"){
        doPlot=TRUE
      }
      if(doPlot==TRUE || (addInitAbund==TRUE && last)){
        col=colvec[i]
        if(last == FALSE && colorBy != ""){
          paramval=unlist(data[colorBy])[i]
          searchparamval=paste(colorBy,paramval,sep="")
          #print(searchparamval)
          if(searchparamval %in% names(param.val.vs.col)){
            param.col=param.val.vs.col[searchparamval]
          }else{
            param.col=param.colors[param.col.counter]
            param.val.vs.col[searchparamval]=param.col
            param.col.counter=param.col.counter+1
          }
          col=unlist(param.col)
          param.plot.colors=c(param.plot.colors,col)
        }
        distribs[,i]=sort(distribs[,i],decreasing=TRUE)
        values=distribs[,i]
        if(logscale==TRUE){
          values=log(values)
        }
        if(pch != ""){
          lines(values,col = col, pch=pch, type="b")
        }else{
          lines(values,col = col)
        }
      }
    }
    print(param.plot.colors)
    if(generator=="all"){
      if(addInitAbund==TRUE){
        legend(x="topright",legend=c(as.character(unique(data$algorithm)),"y"), pch = rep(15,(length(unique(data$algorithm))+1)), col=algcolors, bg="white", text.col="black")
      }else{
        legend(x="topright",legend=unique(data$algorithm), pch = rep(15,length(unique(data$algorithm))), col=algcolors, bg="white", text.col="black")
      }
    }else{
      if(colorBy != ""){
        legend(x="topright",legend=names(param.val.vs.col), pch = rep(15,length(names(param.val.vs.col))), col=unique(param.plot.colors), bg="white", text.col="black")
      }
    }
  }
}

# Extract generator-specific colors and shapes from the result table
getColorVector<-function(table){
  colvec=c()
  pchvec=c()
  for(i in 1:length(table$algorithm)){
    col=""
    # http://www.statmethods.net/advgraphs/parameters.html
    pchar=0
    if(table$interval[i]=="1"){
      pchar=21 # circle
    }else if(table$interval[i] == "5"){
      pchar=22 # square
    }else if(table$interval[i] == "10"){
      pchar=23 # diamond
    }
    pchvec=c(pchvec,pchar)
    #intervalvec=c(intervalvec,intervalcol)
    if(table$algorithm[i]=="ricker"){
      col="blue"
    }else if(table$algorithm[i]=="glv"){
      col="red"
    }else if(table$algorithm[i]=="soc"){
      col="green"
    }else if(table$algorithm[i]=="dm"){
      col="pink"
    }else if(table$algorithm[i]=="hubbell"){
      col="gray"
    }else if(table$algorithm[i]=="davida"){
      col="brown"
    }else if(table$algorithm[i]=="davidb"){
      col="orange"
    }
    colvec=c(colvec,col)
  }
  res=list(colvec,pchvec)
  names(res)=c("colors","symbols")
  return(res)
}

# taken from: http://stackoverflow.com/questions/18509527/first-letter-to-upper-case
firstup <- function(x) {
  substr(x, 1, 1) <- toupper(substr(x, 1, 1))
  x
}

##############################

# task: principal component analysis

# input: x = matrix
#        useCor = boolean, true if correlation should be used (recommended if x is already standardized)
#        verbose = verbosity
#        plot = plot projection of data in two-dimensional space spanned by two components (by default first and second)
#        manual = manually identify datapoints in a plot (to set their names)
#        components = the components (eigenvectors) to use for the plot
#        colvec = vector containing colors to color data points in plot (by default NULL)
#        save = save result in given location
#        location = file or directory/file to save result

# output: result with slots for projection (x projected on subspace), V (eigenvectors, columnwise),
#         d (eigenvalues) and Var (percentage of total variation explained by principal component)

my.pca<-function(x, useCor=F, verbose=F, plot=F, manual=F,components=c(1,2), colvec=NULL, save=F, location="PCAresult.dat"){

  # calculate eigen values and vectors of correlation matrix
  # correlation matrix used if x already divided by standard deviation
  # (covariance of standardized variables equals correlation)
  if(useCor){
    eig=eigen(cor(x, use="pairwise.complete.obs"))
  }else{
    eig=eigen(cov(x, use="pairwise.complete.obs"))
  }
  # eigen values
  d=eig[[1]]
  # eigen vectors (by column)
  V=eig[[2]]

  # calculate total variation and variances explained by the principal components
  total=sum(d)
  i=1
  Var=matrix(0,ncol(x),1)
  while(i<=ncol(x)){
    Var[i,1]=d[i]/total*100
    i=i+1
  }
  dimnames(Var)=list(c(1:ncol(x)),c("percentage of total variation"))
  if(verbose){
    print(Var)
  }

  # calculate projection of x on two-dimensional subspace spanned by selected eigenvectors
  V.project = cbind(V[,components[1]],V[,components[2]])
  x.trans=t(V.project)%*%t(x)

  #Plot
  if(plot){
    par(cex=0.5)
    title=paste("Data in PC ",components[1],"/",components[2]," subspace",sep=" ")
    xlab=paste("PC ",components[1])
    ylab=paste("PC ",components[2])
    if(is.null(colvec)){
      plot(x.trans[1,],x.trans[2,],xlab=xlab,ylab=ylab,main=title)
    }else{
      if(nrow(x)!=length(colvec)){
        print("Error! Given color vector should contain as many colors as x has rows!")
      }
      plot(x.trans[1,],x.trans[2,],xlab=xlab,ylab=ylab, col=colvec)
    }
    text(x.trans[1,],x.trans[2,],pos=2,labels=rownames(x))
    # manually identify data points
    if(manual){
      identify(x.trans[1,],x.trans[2,],labels=rownames(x),plot=T)
    }
  }
  # return results
  result=list()
  result$projection = x.trans
  result$V = V
  result$d = d
  result$Var = Var
  # save result
  if(save){
    cat(result,file=location)
  }
  result
}
